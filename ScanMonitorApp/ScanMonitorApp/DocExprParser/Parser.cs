// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;

namespace TinyPgDocExpr
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

        public ParseTree Parse(string input)
        {
            tree = new ParseTree();
            return Parse(input, tree);
        }

        public ParseTree Parse(string input, ParseTree tree)
        {
            scanner.Init(input);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseStart(ParseNode parent) // NonTerminalSymbol: Start
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.STRINGLITERAL, TokenType.BRACKETOPEN, TokenType.NOT); // Option Rule
            if (tok.Type == TokenType.STRINGLITERAL
                || tok.Type == TokenType.BRACKETOPEN
                || tok.Type == TokenType.NOT)
            {
                ParseExpression(node); // NonTerminal Rule: Expression
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOF); // Terminal Rule: EOF
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Start

        private void ParseLocatedString(ParseNode parent) // NonTerminalSymbol: LocatedString
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.LocatedString), "LocatedString");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.STRINGLITERAL); // Terminal Rule: STRINGLITERAL
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.STRINGLITERAL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRINGLITERAL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BRACEOPEN); // Option Rule
            if (tok.Type == TokenType.BRACEOPEN)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.BRACEOPEN); // Terminal Rule: BRACEOPEN
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRACEOPEN) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACEOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                 // Concat Rule
                tok = scanner.Scan(TokenType.DECIMALINTEGERLITERAL); // Terminal Rule: DECIMALINTEGERLITERAL
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.DECIMALINTEGERLITERAL) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DECIMALINTEGERLITERAL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                 // Concat Rule
                tok = scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                 // Concat Rule
                tok = scanner.Scan(TokenType.DECIMALINTEGERLITERAL); // Terminal Rule: DECIMALINTEGERLITERAL
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.DECIMALINTEGERLITERAL) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DECIMALINTEGERLITERAL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                 // Concat Rule
                tok = scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                 // Concat Rule
                tok = scanner.Scan(TokenType.DECIMALINTEGERLITERAL); // Terminal Rule: DECIMALINTEGERLITERAL
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.DECIMALINTEGERLITERAL) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DECIMALINTEGERLITERAL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                 // Concat Rule
                tok = scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                 // Concat Rule
                tok = scanner.Scan(TokenType.DECIMALINTEGERLITERAL); // Terminal Rule: DECIMALINTEGERLITERAL
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.DECIMALINTEGERLITERAL) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DECIMALINTEGERLITERAL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                 // Concat Rule
                tok = scanner.Scan(TokenType.BRACECLOSE); // Terminal Rule: BRACECLOSE
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRACECLOSE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACECLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: LocatedString

        private void ParseParenthesizedExpression(ParseNode parent) // NonTerminalSymbol: ParenthesizedExpression
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ParenthesizedExpression), "ParenthesizedExpression");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.BRACKETOPEN); // Terminal Rule: BRACKETOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACKETOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

             // Concat Rule
            ParseExpression(node); // NonTerminal Rule: Expression

             // Concat Rule
            tok = scanner.Scan(TokenType.BRACKETCLOSE); // Terminal Rule: BRACKETCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACKETCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ParenthesizedExpression

        private void ParsePrimaryExpression(ParseNode parent) // NonTerminalSymbol: PrimaryExpression
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.PrimaryExpression), "PrimaryExpression");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.STRINGLITERAL, TokenType.BRACKETOPEN); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.STRINGLITERAL:
                    ParseLocatedString(node); // NonTerminal Rule: LocatedString
                    break;
                case TokenType.BRACKETOPEN:
                    ParseParenthesizedExpression(node); // NonTerminal Rule: ParenthesizedExpression
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: PrimaryExpression

        private void ParseUnaryExpression(ParseNode parent) // NonTerminalSymbol: UnaryExpression
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.UnaryExpression), "UnaryExpression");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.STRINGLITERAL, TokenType.BRACKETOPEN, TokenType.NOT); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.STRINGLITERAL:
                case TokenType.BRACKETOPEN:
                    ParsePrimaryExpression(node); // NonTerminal Rule: PrimaryExpression
                    break;
                case TokenType.NOT:

                     // Concat Rule
                    tok = scanner.Scan(TokenType.NOT); // Terminal Rule: NOT
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.NOT) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NOT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                     // Concat Rule
                    ParsePrimaryExpression(node); // NonTerminal Rule: PrimaryExpression
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: UnaryExpression

        private void ParseExpression(ParseNode parent) // NonTerminalSymbol: Expression
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Expression), "Expression");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseUnaryExpression(node); // NonTerminal Rule: UnaryExpression

             // Concat Rule
            tok = scanner.LookAhead(TokenType.PIPE, TokenType.AMP); // ZeroOrMore Rule
            while (tok.Type == TokenType.PIPE
                || tok.Type == TokenType.AMP)
            {

                 // Concat Rule
                tok = scanner.LookAhead(TokenType.PIPE, TokenType.AMP); // Choice Rule
                switch (tok.Type)
                { // Choice Rule
                    case TokenType.PIPE:
                        tok = scanner.Scan(TokenType.PIPE); // Terminal Rule: PIPE
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.PIPE) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PIPE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    case TokenType.AMP:
                        tok = scanner.Scan(TokenType.AMP); // Terminal Rule: AMP
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.AMP) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.AMP.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                } // Choice Rule

                 // Concat Rule
                ParseUnaryExpression(node); // NonTerminal Rule: UnaryExpression
            tok = scanner.LookAhead(TokenType.PIPE, TokenType.AMP); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Expression


    }

    #endregion Parser
}
