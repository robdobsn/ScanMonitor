using MongoDB.Driver;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using NLog;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using MongoDB.Driver.Builders;

// TinyPgDocExpr namespace for the parser - generated by TinyPG v1.3 available at www.codeproject.com

namespace ScanMonitorApp
{
    class DocTypesMatcher
    {
        private static Logger logger = LogManager.GetCurrentClassLogger();
        private MongoClient _dbClient;
        private string _dbNameForDocTypes;
        private string _dbCollectionForDocTypes;
        //private TinyPgDocExpr.Scanner _scanner;
        //private TinyPgDocExpr.Parser _parser;

        public DocTypesMatcher(string dbNameForDocTypes, string dbCollectionForDocTypes)
        {
            _dbCollectionForDocTypes = dbCollectionForDocTypes;
            _dbNameForDocTypes = dbNameForDocTypes;
            var connectionString = "mongodb://localhost";
            _dbClient = new MongoClient(connectionString);

            //// Create parser and scanner
            //_scanner = new TinyPgDocExpr.Scanner();  // scanner for doc expressions
            //_parser = new TinyPgDocExpr.Parser(_scanner);
        }

        private MongoCollection<DocType> GetDocTypesCollection()
        {
            // Setup db connection
            var server = _dbClient.GetServer();
            var database = server.GetDatabase(_dbNameForDocTypes); // the name of the database
            return database.GetCollection<DocType>(_dbCollectionForDocTypes);
        }

        public DocTypeMatchResult GetMatchingDocType(ScanDocAllInfo scanDocAllInfo)
        {
            // Setup db connection
            var server = _dbClient.GetServer();
            var database = server.GetDatabase(_dbNameForDocTypes); // the name of the database
            var collection_doctypes = database.GetCollection<DocType>(_dbCollectionForDocTypes);

            // Get list of types
            MongoCursor<DocType> foundSdf = collection_doctypes.FindAll();
            foreach (DocType doctype in foundSdf)
            {
                // Check if document matches
                DocTypeMatchResult matchResult = CheckIfDocMatches(scanDocAllInfo, doctype);
                if (matchResult.matchCertaintyPercent == 100)
                    return matchResult;
            }
            return new DocTypeMatchResult();
        }


        public DocTypeMatchResult CheckIfDocMatches(ScanDocAllInfo scanDocAllInfo, DocType docType)
        {
            // Setup check info
            DocTypeMatchResult matchResult = new DocTypeMatchResult();
            matchResult.matchCertaintyPercent = 0;
            if (docType.matchExpression == null)
                return matchResult;

            // Check the expression
            if (!MatchAgainstDocText(docType.matchExpression, scanDocAllInfo.scanPages))
                matchResult.matchCertaintyPercent = 100;
 
            return matchResult;
        }

        public bool MatchAgainstDocText(string matchExpression, List<ScanPageText> scanPages)
        {
            //// Parse the match expresson
            //TinyPgDocExpr.ParseTreeEval tree = new TinyPgDocExpr.ParseTreeEval();
            //tree = _parser.Parse(matchExpression, tree) as TinyPgDocExpr.ParseTreeEval;
            //if (tree.Errors.Count > 0)
            //    return false;
            StringTok st = new StringTok(matchExpression);
            return EvalMatch(st, scanPages);
        }

        public bool EvalMatch(StringTok st, List<ScanPageText> scanPages)
        {
            bool result = false;
            string token = "";
            bool curOpIsOr = true;
            while((token = st.GetNextToken()) != null)
            {
                if (token == "")
                    continue;
                else if (token == ")")
                    return result;
                else if (token == "(")
                    result = EvalMatch(st, scanPages);
                else if (token == "&")
                    curOpIsOr = false;
                else if (token == "|")
                    curOpIsOr = true;
                else if (curOpIsOr)
                    result |= MatchString(token, new DocRectangle(0, 0, 100, 100), scanPages);
                else
                    result &= MatchString(token, new DocRectangle(0, 0, 100, 100), scanPages);                
            }
            return result;
        }

        public bool MatchString(string str, DocRectangle docRec, List<ScanPageText> scanPages)
        {
            for (int pageIdx = 0; pageIdx < scanPages.Count; pageIdx++)
            {
                ScanPageText scanPageText = scanPages[pageIdx];
                foreach (ScanTextElem textElem in scanPageText.textElems)
                {
                    // Check bounds
                    if (docRec.Contains(textElem.bounds))
                    {
                        if (textElem.text.IndexOf(str, StringComparison.OrdinalIgnoreCase) >= 0)
                            return true;
                    }
                }
            }
            return false;
        }

        public class StringTok
        {
            public string[] tokens;
            public int curPos = 0;

            public StringTok (string inStr)
            {
                //char[] terms = new char[] {'(', ')', '&', '|' };
                //tokens = inStr.Split(terms);
                string pattern = @"(\()|(\))|(\&)|(\|)";
                tokens = Regex.Split(inStr, pattern);
                curPos = 0;
            }

            public string GetNextToken()
            {
                if (curPos >= tokens.Length)
                    return null;
                return tokens[curPos++];
            }
        }

        public string ListDocTypes()
        {
            // Get list of documents
            MongoCollection<DocType> collection_doctypes = GetDocTypesCollection();
            List<DocType> docTypeList = collection_doctypes.FindAll().ToList<DocType>();
            return JsonConvert.SerializeObject(docTypeList);
        }

        public string GetDocType(string docTypeName)
        {
            // Get first matching document
            MongoCollection<DocType> collection_doctypes = GetDocTypesCollection();
            DocType docType = collection_doctypes.FindOne(Query.EQ("docTypeName", docTypeName));
            return JsonConvert.SerializeObject(docType);
        }

        public void AddDocTypeRecToMongo(DocType docType)
        {
            // Mongo append
            try
            {
                MongoCollection<DocType> collection_docTypes = GetDocTypesCollection();
                collection_docTypes.Insert(docType);
                // Log it
                logger.Info("Added doctype record for {0}", docType.docTypeName);
            }
            catch (Exception excp)
            {
                logger.Error("Cannot insert doctype rec into {0} Coll... {1} for file {2} excp {3}",
                            _dbNameForDocTypes, _dbCollectionForDocTypes, docType.docTypeName,
                            excp.Message);
            }
        }

        // Test code
        public void AddOldDocTypes(string filename)
        {
            ScanMan.OldXmlRulesManager xmlRulesManager = new ScanMan.OldXmlRulesManager(filename);
            List<ScanMan.OldXmlRulesManager.DocType> oldDocTypeList = xmlRulesManager.GetAllDocTypes();

            // Handle match expression
            foreach (ScanMan.OldXmlRulesManager.DocType oldDocType in oldDocTypeList)
            {
                DocType newDocType = new DocType();
                newDocType.docTypeName = oldDocType.dtName;
                if (oldDocType.goodStrings.Count > 0)
                {
                    newDocType.matchExpression = "(";
                    foreach (ScanMan.OldXmlRulesManager.CheckItem chkItem in oldDocType.goodStrings)
                    {
                        if (newDocType.matchExpression != "(")
                            newDocType.matchExpression += "&";
                        newDocType.matchExpression += "(" + chkItem.checkString + ")";
                    }
                    newDocType.matchExpression += ")";
                }
                string notStr = "";
                if (oldDocType.badStrings.Count > 0)
                {
                    notStr = "(";
                    foreach (ScanMan.OldXmlRulesManager.CheckItem chkItem in oldDocType.badStrings)
                    {
                        if (notStr != "(")
                            notStr += "&";
                        notStr += "(" + chkItem.checkString + ")";
                    }
                    notStr += ")";
                }
                if (notStr != "")
                    newDocType.matchExpression += "!" + notStr;

                // Handle thumbnail
                if (oldDocType.thumbFileNames.Count > 0)
                    newDocType.thumbnailForDocType = oldDocType.thumbFileNames[0].Replace('\\', '/');
                else
                    newDocType.thumbnailForDocType = "";
                AddDocTypeRecToMongo(newDocType);
            }
        }
    }
}
